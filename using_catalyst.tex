\section{Using Catalyst}
\label{sec:catalyst}
Catalyst is the general purpose coprocessing library of ParaView. This means
that it was designed to work with any simulation code. This behavior is
possible thanks to the use of an adaptor-based architecture. The adaptor binds
the simulation code and Catalyst; it can access both the functions of the
simulation code and the general-purpose API of Catalyst. As Catalyst itself is
independent of the simulation code it is only the adaptor that should be
implemented by the designers of the solver. In our case, we have developed a specific adaptor for
Code\_Saturne. Further explanations on the Catalyst design can be found in
~\cite{6092322}.
All our tests were run on “ParaView 3.98.0 enhanced” and “ParaView 3.98.1”. 

\subsection{Implementing the adaptor}

We identified two main issues to implement our adaptor, the memory management and the handling of ghost cell informations. 

\subsubsection{Memory management}
In order to coprocess the simulation data, Catalyst must be provided with the
data formatted to the VTK data object structure. To accomplish this, several
solutions are possible, essentially depending on the format used for the data
of the simulation code. In the case when the format of the simulation code is
similar to VTK  and, moreover, the simulation data can be shared at any time,
then it is possible to feed Catalyst with a direct pointer to the simulation
memory. Another option is to fully or partially copy the data from the
simulation into a VTK object, and to send this object to Catalyst.

As we provide users of Code\_Saturne with several output formats and as our data
structure in the simulation differs from the VTK data object structure, feeding
Catalyst with a direct pointer to the simulation memory is not possible. Thus,
we chose to copy data from the simulation into a VTK data object. In fact, we
are allocating vtkDoubleArray to store our data for Catalyst. Furthermore, we
provide a pointer of those vtkDoubleArray to Code\_Saturne so it can transform
its simulation data and then fill the VTK data object.

The memory cost increase of our solution can be  alleviated by using more
machines. The cpu cost of the copy is in a range similar to the one needed when
adapting simulation data to a specific output format. This cost is largely
affordable comparatively to the time to write data to disk when storing time
step specific outputs. 

We are currently working on the evolution of our solution. Indeed Kitware plans to
add specific $in$-$situ$ data structures to VTK. This will offer adaptor
developers facilities to make VTK access non VTK compatible simulation data. 

\subsubsection{Handling ghost cells: the vtkDistributedDataFilter}
Handling ghost cell informations is also an important issue for us. Indeed,
several Code\_Saturne features and visualization filters in ParaView rely on the
use of ghost data. Thus allowing the Code\_Saturne and ParaView users to access
this feature is an important objective in our industrial environment.

To address this need, we first tried to rely on the setting of nodes GlobalIds
in order to see if ghost data exchanges between neighbors were already handled
by Catalyst. Indeed ParaView implements a global numbering strategy on its
nodes by using the so-called “GlobalIds”.  While the setting of these GlobalIds
is relevant for the handling of ghost cell informations in ParaView, Catalyst
does not actually use them. As we want Code\_Saturne users to be able to use the
larger scale of both simulation and visualization algorithms, we decided to
force the application of the vtkDistributedDataFilter (D3) filter in the
visualization pipeline. This D3 filter originally performs a redistribution of
the data among the MPI processes but we use it to manage the ghost cells. 

\subsection{Pipeline Configuration Tools}
\label{sec:pip_conf_tools}
From the point of view of an engineer performing a fluid mechanics simulation
using Code\_Saturne, the workflow of a coprocessing-simulation is: 1) to define
a ParaView pipeline describing what the user wants to study and 2) to run the
simulation. As users are already familiar with how to perform fluid mechanics
simulations, defining the pipeline for the coprocessing will be their main
issue. Thus this new process should be done in an efficient and easy way, at
least this part should not become a cumbersome bottleneck. In our industrial
environment this point is of great importance.

The definition of a Catalyst pipeline is possible in two ways. First, the
pipeline can be defined programatically, a solution that we evaluate as too
complicated and time consuming for the end user, especially when setting camera
parameters is needed. Secondly,  the pipeline can be created using the ParaView
user's interface. This second solution is much easier for the user as he/she
can  simply interact with ParaView in the same way he/she used to when
visualizing the results a posteriori. This last solution is the one we 
opted for and it can
be performed after activating the coprocessing plugin in ParaView. 

However, the chosen strategy for defining the pipeline implies a potential
important bottleneck that we want to discuss in detail. Indeed, how can we a
priori define a pipeline on the large geometry and fields that are going to
be used in the simulation ? This is by itself a challenge and could imply a
dedicated parallel system only to define the pipeline. Our solution consists in
using a simplified or under-sampled version of the large geometry to define the
pipeline. In fact, this strategy is possible in ParaView but some
characteristics of the initial geometry must be present in its simplified version (principally equal
names of fields).

Finally, the workflow of our engineers implies several steps to define the
pipeline.  First of all, the users possess a CAD (Computer Aided Design)
version of the geometry that is parametrized. This parametric representation
can generate meshes at different resolution factors. In our case, this is
performed inside the open-source SALOME~\cite{4291178} platform for numerical simulation. 

We generate two different meshes, one at high resolution (up to 204M
hexahedrals in the use cases of this article) that will be used for the CFD
simulation and one with a lower resolution to define the pipeline (700 000
hexahedrals in our use cases). The lowest resolution mesh is fed into Code\_Saturne to perform a short
simulation. This allows ParaView to obtain a representation containing not
only the geometry but also the result fields. This is the data that is 
actually used to define the pipeline.

